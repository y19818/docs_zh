---
id：storage-staking
title：存储权益
sidebar_label: 存储权益
---

> 当你在NEAR上部署一个智能合约时，你会使用一种叫做存储权益的机制来支付这个合约所需要的存储。
>
> 在存储权益（有时也被称为_状态权益）中，拥有智能合约的账户必须根据该智能合约中存储的数据量对代币进行抵押（或锁定），从而有效减少合约账户的余额。

<blockquote class="info">。
<strong>来自以太坊？</strong><br><br>。

如果你熟悉以太坊的定价模式，你可能会知道，与NEAR一样，该协议对每笔交易收取费用（称为 “gas"）。与NEAR不同的是，以太坊的gas费由该笔交易存储的数据量计算得出。这本质上意味着任何人都可以支付一次费用来存储链上的永久数据。这是一个糟糕的经济设计，至少有两个原因。1. 运行网络的人（矿工，以以太坊1为例）没有适当的激励来存储大量数据，因为在过去收取的gas费会永远增加存储成本；2. 智能合约的用户要为他们发送的数据存储在合约中而收费，而不是向智能合约的所有者收费。
</blockquote>

## NEAR的设计如何调整激励机制？

存储型代币无法用于其他用途，比如验证抵押。这增加了验证者将获得的收益率。更多信息请参见[经济学白皮书]（https://near.org/papers/economics-in-sharded-blockchain/）。

## 代币什么时候会被抵押？

在每个添加数据的临近交易中。

让我们通过一个例子来了解一下。

1. 你启动[一个留言簿应用](https://examples.near.org/guest-book)，将你的应用的智能合约部署到账户`example.near`中。
2. 您的应用程序的访问者可以将消息添加到留言簿。这意味着您的用户将，[默认](/docs/concepts/gas#what-about-prepaid-gas)，支付少量的gas费用，将他们的信息发送到您的合同。
3. 当这样的电话打进来时，NEAR会检查`example.near`是否有足够大的余额，可以抵押一笔钱来满足新的存储需求。如果没有，交易将失败。

## "百万廉价数据添加 "攻击

请注意，这可能会产生一个攻击面。继续上面的例子，如果向你的留言簿发送数据的成本接近于零，而合约所有者的成本却大大增加，那么恶意用户就可以利用这种不平衡，使维护合约的成本高得令人望而却步。

那么，在设计你的智能合约时要小心，确保这种攻击让潜在的攻击者付出的代价大于他做这件事情的价值。

## 另外，你可以删除数据来解锁一些代币

熟悉关于区块链的 "不可改变的数据 "叙述的人发现这一点令人惊讶。虽然一个_索引节点_确实会永远保留所有数据，但_验证节点_（即网络中大多数验证者运行的节点）却不会。智能合约可以提供删除数据的方法，这些数据将在几个[纪元](/docs/concepts/epoch)内从网络中的大多数节点中清除。

请注意，调用你的智能合约来删除数据会有相关的gas费。考虑到NEAR的gas费用限制，这就为单次交易中可以删除多少数据建立了一个上限。

## 它的成本是多少？

存储权益的价格是由网络设定的金额，初始化为 **[每字节1E20 yoctoNEAR](https://github.com/near/nearcore/blob/2141bdafc57def7793708dcfcbf6aaea4c56e2c5/neard/res/mainnet_genesis.json#L32)** ， 或**每个NEAR代币10kb（Ⓝ）**。

这个值在未来可能会改变。NEAR的JSON RPC API提供了[查询这个初始设置的方法](/docs/develop/front-end/rpc#genesis-config)，但还没有提供查询 "实时 "配置值的方法。在它改变之前，本文档将被更新，以包含如何查询实时版本的信息。

## 成本明细示例

让我们通过一个例子来了解一下。

一个[不可互换的代币](https://github.com/nearprotocol/NEPs/pull/4)是独一无二的，这意味着每个代币都有自己的ID。合约必须存储一个从代币ID到所有者账户ID的映射。

如果用这样的NFT来追踪**100万**个代币，那么代币ID到所有者的映射需要多少存储量？而这些存储需要多少代币进行抵押？

以[这个基本的汇编脚本实现](https://github.com/near-examples/NFT/tree/master/contracts/assemblyscript/nep4-basic)为灵感，让我们来计算一下使用`near-sdk-as`的[`永久映射`](https://near.github.io/near-sdk-as/classes/_sdk_core_assembly_collections_persistentmap_.persistentmap.html)时的存储需求。虽然它的具体实现可能会在未来发生变化，但在写文章的时候，`near-sdk-as`将数据存储为UTF-8字符串。下面我们就假设这一点。

这就是我们的`永久映射`。

```ts
type AccountId = string
type TokenId = u64
const tokenToOwner = new PersistentMap<TokenId, AccountId>('t2o')
```

在幕后，NEAR区块链上存储的所有数据都保存在一个键值数据库中。那个传递给`永久映射`的`'t2o'`变量可以帮助它跟踪所有的值。如果你的账户`example.near`拥有ID`0`的token，那么在写这篇文章的时候，这里的数据将被保存到键值数据库中。

* key: `t2o::0` * value: `example.
* value：`example.near`。

那么对于100万的代币，下面就是我们需要加起来乘以100万的东西。

1. 前缀 `t2o`将被序列化为UTF-8的三个字节，两个冒号将再增加两个。也就是5个字节。
2. 对于`TokenId`自动递增的实现，其值将在`0`和`999999`之间，这样平均长度为5个字节。
3. 让我们假设格式良好的NEAR`AccountId`s，让我们猜测NEAR账户ID遵循域名的近似模式，这些域名[平均约10个字符](https://www.domainregistration.com.au/news/2013/1301-domain-length.php)，再加上`.near`这样的顶级名称。所以一个合理的平均预期可能是大约15个字符；让我们保守的估计，25个。这将等于25个字节，因为NEAR账户ID必须使用ASCII集的字符。

所以，我们的估计是：

    1_000_000 * (5 + 5 + 25)

3500万字节。乘以每字节1e20 yoctoNEAR，我们发现`tokenToOwner`映射需要抵押3.5e27 yoctoNEAR或Ⓝ3,500。

请注意，你可以把前缀从`t2o`改成一个字符，就可以把这个数字降为Ⓝ3,300。或者完全去掉它! 你可以在智能合约中的一个`永久向量`上有一个零长度的前缀。如果你对这个做了，你可以把它降为Ⓝ3.2。


## 为你自己的合约计算成本

如上图所示，手动进行字节计算是很困难的，而且容易出错。好消息：你不必这样做!

你可以在单元测试中测试使用的存储。

* 使用[`near-sdk-as`](https://near.github.io/near-sdk-as)，导入`env`并检查`env.storage_usage()` - [例子](https://github.com/near/near-sdk-as/blob/b308aa48e0bc8336b458f05a231409be4dee6c69/sdk/assembly/__tests__/runtime.spec.ts#L156-L200)

你也可以在模拟测试中测试存储；请查看[这个模拟测试示例](https://github.com/near-examples/simulation-testing)来开始。


## 其他降低成本的方法

对于运行网络的人来说，链上存储数据并不便宜，NEAR将这个成本转嫁给了开发者。那么，作为开发者，如何降低成本呢？有两种流行的方法。

1. 使用二进制序列化格式，而不是JSON。
2. 将数据存储在链外

### 使用二进制序列化格式，而不是JSON。

NEAR核心团队维护了一个名为[borsh](https://borsh.io/)的库。
当你使用`near-sdk-rs`时，它会自动使用。有一天，它可能也会被`near-sdk-as`使用。

想象一下，你想存储一个数组，比如"[0, 1, 2, 3]"。你可以将它序列化为一个字符串，并将其存储为UTF-8字节。这就是今天`near-sdk-as`所做的。去掉空格，你最终使用9个字节。

使用borsh，同样的数组被保存为8个字节。

    \u0004\u0000\u0000\u0000\u0000\u0001\u0002\u0003

乍一看，节省1个字节似乎并不重要。但我们仔细看看。

这里的前四个字节，"/u0004u0000/u0000/u0000"，告诉序列发生器这是一个长度为`4`的`u32`数组，使用小二进制编码。剩下的字节是数组的字面数字– `\u0000\u0001\u0002\u0003`。当你序列化更多的元素时，每一个元素会给数据结构增加一个字节。在JSON中，每个新元素都需要增加两个字节，来代表另一个逗号和数字。

一般来说，Borsh速度更快，使用的存储空间更少，成本更低。如果可以的话，请使用它。

### 将数据存储在链外

如果你存储的是用户生成的数据，这一点尤为重要!

我们以这个[留言簿](https://github.com/near-examples/guest-book)为例。按照今天的工具，访客可以用NEAR登录应用并留言。他们的留言会被存储在链上。

想象一下，这个应用变得非常流行，访客开始意外地留下长长的留言。合约所有者可能很快就会耗尽存储的资金!

更好的策略可能是将数据存储在链外。如果你想保持应用的去中心化，一个流行的链外数据存储方案是[IPFS]（https://ipfs.io/）。有了它，你可以用一个可预测的内容地址来表示任何一组数据，比如。

    QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG。

这样的内容地址可以代表一个JSON结构或图像或任何其他类型的数据。这些数据会被物理存储在哪里？你可以使用[Filecoin](https://filecoin.io/)或运行你自己的IPFS服务器来钉住你的应用程序的数据。

通过这种方法，你添加到合约中的每一条都将是可预测大小的记录。

## 总结

NEAR的结构在激励网络运营商的同时，也为合约开发者提供了灵活性和可预测性。管理存储是智能合约设计的一个重要方面，NEAR的库可以轻松计算出你的应用需要多少存储成本。

>Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol">
  <h8>Ask it on StackOverflow!</h8></a>
